#!/bin/bash

##############################################
# Git Hook: Pre-commit Image Optimization
# Red Den Connexion - Automatisation
#
# Ce hook compresse automatiquement les images
# avant chaque commit
#
# v2.0 - D√©tection intelligente des images
#        d√©j√† optimis√©es
##############################################

# Couleurs
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

echo ""
echo -e "${BLUE}üñºÔ∏è  Git Hook: Optimisation automatique des images${NC}"
echo -e "${BLUE}=================================================${NC}"
echo ""

# V√©rifier si ImageMagick est install√©
if ! command -v convert &> /dev/null; then
    echo -e "${YELLOW}‚ö†Ô∏è  ImageMagick n'est pas install√©${NC}"
    echo ""
    echo "Pour activer l'optimisation automatique, installez ImageMagick:"
    echo "  Ubuntu/Debian: sudo apt install imagemagick optipng"
    echo "  macOS: brew install imagemagick optipng"
    echo ""
    echo -e "${YELLOW}‚Üí Commit sans optimisation (utilisez --no-verify pour ignorer ce message)${NC}"
    echo ""
    exit 0
fi

# R√©cup√©rer toutes les images JPG/PNG dans le staging area
IMAGES=$(git diff --cached --name-only --diff-filter=ACM | grep -iE '\.(jpe?g|png)$')

if [ -z "$IMAGES" ]; then
    echo -e "${GREEN}‚úÖ Aucune image √† optimiser${NC}"
    echo ""
    exit 0
fi

echo -e "${BLUE}üìã Images d√©tect√©es:${NC}"
echo "$IMAGES" | while read img; do
    echo "   - $img"
done
echo ""

# Seuil minimum de gain pour optimiser (en %)
MIN_GAIN_THRESHOLD=5

# Fonction pour v√©rifier si une image a besoin d'optimisation
needs_optimization() {
    local file="$1"
    local size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
    local size_mb=$(echo "scale=2; $size / 1024 / 1024" | bc)

    # Si l'image fait moins de 100KB, probablement d√©j√† optimis√©e
    if [ "$size" -lt 102400 ]; then
        return 1  # Pas besoin
    fi

    # V√©rifier la qualit√© JPG (si c'est un JPG)
    local extension="${file##*.}"
    extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')

    if [[ "$extension" == "jpg" || "$extension" == "jpeg" ]]; then
        # Extraire la qualit√© JPG si possible
        local quality=$(identify -format "%Q" "$file" 2>/dev/null)

        # Si qualit√© entre 80-90, probablement d√©j√† optimis√©e
        if [ -n "$quality" ] && [ "$quality" -ge 80 ] && [ "$quality" -le 90 ]; then
            # Mais si l'image est tr√®s grosse (>1MB), optimiser quand m√™me
            if [ "$size" -lt 1048576 ]; then
                return 1  # Pas besoin
            fi
        fi
    fi

    return 0  # Besoin d'optimisation
}

# Fonction pour optimiser une image
optimize_image() {
    local file="$1"

    # V√©rifier que le fichier existe
    if [ ! -f "$file" ]; then
        return 1
    fi

    # Obtenir la taille originale
    local original_size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)

    # V√©rifier si l'image a besoin d'optimisation
    if ! needs_optimization "$file"; then
        local size_kb=$(echo "scale=1; $original_size / 1024" | bc)
        echo -e "${CYAN}‚è≠Ô∏è  $file${NC}"
        echo "   ${size_kb}KB - D√©j√† optimis√©e (ignor√©e)"
        return 0
    fi

    # Cr√©er un fichier temporaire
    local temp_file="${file}.tmp"

    # D√©tecter le type d'image
    local extension="${file##*.}"
    extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')

    case "$extension" in
        jpg|jpeg)
            # Optimiser JPG
            convert "$file" \
                -strip \
                -interlace Plane \
                -quality 85 \
                -sampling-factor 4:2:0 \
                "$temp_file" 2>/dev/null
            ;;
        png)
            # Optimiser PNG
            convert "$file" \
                -strip \
                -define png:compression-level=9 \
                "$temp_file" 2>/dev/null

            # Si optipng est disponible, optimiser encore plus
            if command -v optipng &> /dev/null; then
                optipng -quiet -o7 "$temp_file" 2>/dev/null
            fi
            ;;
        *)
            return 1
            ;;
    esac

    # V√©rifier que l'optimisation a r√©ussi
    if [ ! -f "$temp_file" ]; then
        echo -e "${RED}‚ùå Erreur lors de l'optimisation de $file${NC}"
        return 1
    fi

    # Obtenir la nouvelle taille
    local new_size=$(stat -c%s "$temp_file" 2>/dev/null || stat -f%z "$temp_file" 2>/dev/null)

    # Calculer le gain en pourcentage
    local reduction=$(echo "scale=1; (($original_size - $new_size) * 100) / $original_size" | bc)
    local reduction_int=$(echo "$reduction" | cut -d'.' -f1)

    # V√©rifier que le gain est significatif
    if [ "$reduction_int" -lt "$MIN_GAIN_THRESHOLD" ]; then
        echo -e "${CYAN}‚è≠Ô∏è  $file${NC}"
        echo "   Gain minimal (${reduction}%) - Image d√©j√† bien optimis√©e"
        rm -f "$temp_file"
        return 0
    fi

    # V√©rifier que l'optimisation n'a pas augment√© la taille
    if [ "$new_size" -ge "$original_size" ]; then
        echo -e "${CYAN}‚è≠Ô∏è  $file${NC}"
        echo "   Optimisation inutile (taille identique ou plus grande)"
        rm -f "$temp_file"
        return 0
    fi

    # Remplacer l'original par la version optimis√©e
    mv "$temp_file" "$file"

    # Afficher le r√©sultat
    local original_kb=$(echo "scale=1; $original_size / 1024" | bc)
    local new_kb=$(echo "scale=1; $new_size / 1024" | bc)

    echo -e "${GREEN}‚úÖ $file${NC}"
    echo "   ${original_kb}KB ‚Üí ${new_kb}KB (-${reduction}%)"

    # Re-stagifier le fichier optimis√©
    git add "$file"

    return 0
}

# Optimiser chaque image
echo -e "${BLUE}üîÑ Analyse et optimisation...${NC}"
echo ""

optimized_count=0
skipped_count=0
failed_count=0

while IFS= read -r image; do
    if [ -f "$image" ]; then
        result_msg=$(optimize_image "$image")
        exit_code=$?

        echo "$result_msg"

        if echo "$result_msg" | grep -q "‚úÖ"; then
            optimized_count=$((optimized_count + 1))
        elif echo "$result_msg" | grep -q "‚è≠Ô∏è"; then
            skipped_count=$((skipped_count + 1))
        elif echo "$result_msg" | grep -q "‚ùå"; then
            failed_count=$((failed_count + 1))
        fi
    fi
done <<< "$IMAGES"

echo ""
echo -e "${BLUE}=================================================${NC}"
echo -e "${GREEN}‚ú® Traitement termin√© !${NC}"
echo -e "${BLUE}=================================================${NC}"

if [ $optimized_count -gt 0 ]; then
    echo -e "${GREEN}‚úÖ Optimis√©es: $optimized_count image(s)${NC}"
fi

if [ $skipped_count -gt 0 ]; then
    echo -e "${CYAN}‚è≠Ô∏è  Ignor√©es: $skipped_count image(s) (d√©j√† optimis√©es)${NC}"
fi

if [ $failed_count -gt 0 ]; then
    echo -e "${RED}‚ùå Erreurs: $failed_count image(s)${NC}"
fi

echo ""

exit 0
